1. Мотивация
Система компании «Александрит» обрабатывает заказы с участием нескольких изолированных сервисов — интернет-магазина, CRM, MES и промежуточной очереди сообщений RabbitMQ.
Команда регулярно сталкивается с ситуациями, когда заказы зависают на одном из этапов обработки и отсутствует понимание, где именно возник сбой.

Трейсинг даст возможность:
1. отслеживать путь конкретного заказа по всем системам (end-to-end),
2. локализовать узкие места и сбои в цепочке,
3. фиксировать потери или задержки сообщений в очереди,
4. сократить время на отладку инцидентов,
5. обеспечить бизнесу прозрачность в статусах заказов.

Бизнес-метрики, на которые повлияет внедрение трейсинга:
1. Среднее время выполнения заказа
2. Количество зависших заказов
3. Cреднее время на устранение инцидента

Компромиссы:
Потребуется модификация кода всех API-сервисов (интернет-магазина, CRM и MES) для интеграции с OpenTelemetry. Это означает необходимость внедрения SDK, настройки проксирования traceId, а также пересмотра обработки входящих и исходящих запросов, включая RabbitMQ.
Особенно это актуально для MES API. Также не все действия можно точно зафиксировать через трейсинг. Например, действия оператора в пользовательском интерфейсе MES (выбор заказа, запуск упаковки) не всегда инициируют API-запросы, что усложняет привязку этих операций к единой цепочке трейсинга.
В таких случаях возможны провалы в наблюдаемости, и потребуется доработка фронтенда, чтобы проксировать события в бекенд.
Cистема трейсинга, особенно при росте нагрузки, может стать дополнительным источником расхода ресурсов. Большое количество спанов приводит к увеличению объёма данных в системе хранения трейсов, а также к росту сетевого трафика между компонентами.
Поэтому потребуется настройка выборочного трейсинга, чтобы не перегружать инфраструктуру.
Ну и полноценное внедрение трейсинга может занять несколько итераций, особенно в тех компонентах, которые обрабатывают сообщения асинхронно или используют устаревшие подходы к логированию.

Безопасность:
Можно вход в Jaeger настроить через SSO и дать доступы только DevOps.
Или же скорее всего в Jaeger можно ограничить видииость в зависимости от ролей.
Настриваются роли и в зависимости от этого внешние (вообще могут через ключи) и внутренние через SSO просматривать в соответсвии с правами.


Предлагаемое решение (объяснение стрелок из Draw.io)
В рамках внедрения распределённого трейсинга в компании «Александрит» все основные API-сервисы интегрируются с OpenTelemetry SDK.
Это позволяет фиксировать каждый шаг обработки заказа и передавать структурированные трейсы в центральный компонент — OpenTelemetry Collector, откуда они направляются в Jaeger.

1. Из Shop API в OpenTelemetry Collector
Когда пользователь оформляет заказ в интернет-магазине, сервис Shop API инициирует цепочку действий: отправляет HTTP-запросы, записывает данные в базу, ставит сообщение в очередь (RabbitMQ).
Все эти действия автоматически оборачиваются в трейсы с помощью OpenTelemetry SDK. Для каждого действия создаётся span и в нем:
1.1 traceId — идентификатор всей цепочки обработки заказа
1.2 spanId — уникальный идентификатор конкретного действия, например submitOrder
1.3 service.name — имя сервиса, например shop-api
1.4 operation.name — название действия (SubmitOrder)
1.5 startTimestamp, duration — временные метки начала и продолжительности операции
1.6 status — успешность операции (OK или ERROR)
1.7 дополнительные метки, такие как userId, orderId, http.status_code
Сформированный трейсовый контекст передаётся в OpenTelemetry Collector по протоколу OTLP. Таким образом, каждый заказ фиксируется в виде цепочки спанов, начинающейся на уровне фронта.
На диаграмме стрелка от Shop API в OpenTelemetry Collector с подписью OTLP trace export (submitOrder, queuePush)

2. Из CRM API в OpenTelemetry Collector
После того как MES рассчитал стоимость изделия, он отправляет сообщение в очередь. Его обрабатывает CRM API, обновляя статус заказа и взаимодействуя с базой данных. Эти действия также оборачиваются в трейсы. Также создается спаны:
2.1 ReceiveFromRabbitMQ — получение сообщения
2.2 ConfirmOrderInDB — обновление записи в БД
2.3 SendToMES — возможное дальнейшее взаимодействие
Все трейсы передаются в Collector с тем же traceId, что и в Shop API, что позволяет связать действия между сервисами в единую цепочку.
На диаграмме стрелка от CRM API в OpenTelemetry Collector с подписью OTLP trace export (confirmOrder, crmUpdate)

3. Из MES API в OpenTelemetry Collector
Сервис MES API играет ключевую роль, поскольку именно здесь происходят наиболее ресурсоёмкие операции: извлечение 3D-модели из S3, расчёт стоимости и отправка результата в CRM. Каждое из этих действий фиксируется тоже как отдельный span:
3.1 StartCalculation — начало расчёта
3.2 FetchFromS3 — извлечение модели
3.3 UpdateStatus PRICE_CALCULATED — обновление статуса заказа
3.4 WriteToQueue — публикация результата в очередь
На диаграмме стрелка от MES API в OpenTelemetry Collector с подписью OTLP trace export (calculatePrice, sendResult)

4. И в конце OpenTelemetry Collector в Jaeger
OpenTelemetry Collector выполняет роль центрального приёмника всех трейсов. Он агрегирует данные от всех API-сервисов, может применять фильтрацию или sampling (чтобы не перегружать хранилище), и пересылает данные в систему визуализации Jaeger.
В Jaeger трейсы визуализируются в виде диаграмм:
4.1 последовательность спанов
4.2 длительность каждого этапа
4.3 наличие ошибок или превышений времени
4.4 связность между сервисами
На диаграмме стрелка от OpenTelemetry Collector в Jaeger с подписью Trace data (OTLP → Jaeger ingest)

ФАЙЛ DRAW.IO КЛАДУ В ДИРЕКТОРИЮ TASK3
